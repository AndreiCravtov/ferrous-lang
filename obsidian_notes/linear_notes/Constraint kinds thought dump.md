# Kinds, contexts, and `Constraint`-kinded types
Haskell has the concept of **kind** of a **type**, i.e. the "type" of a **type** (this [might not be strictly true](https://serokell.io/blog/datakinds-are-not-what-you-think) but good enough for intuition)
- Values have a **type**, i.e. `constNum :: Int`, `flip :: (a -> b -> c) -> b -> a -> c`, etc.
- Types have **kind**, i.e. `Int :: Type`, `Maybe :: Type -> Type`, etc.

Normally **constraints**, which appear in **type**s before `=>` arrow e.g. `eq :: Eq a => a -> a -> Bool`, have a very restricted syntax
- Class constraints, e.g. `Eq a`
- [Implicit parameter](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/implicit_parameters.html) constraints, e.g. `?x::Int`
- [Equality](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/equality_constraints.html), e.g. `a ~ Int`

And with [ConstraintKinds](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/constraint_kind.html) *(and [FlexibleContexts](https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/flexible_contexts.html) and to make it useful)* you get a new `Constraint` **kind**, and all **constraint**s `c` are **type**s `c :: Constraint`.
- Classes become **type**s of **kind** e.g. `Eq :: Type -> Constraint` so `Eq a :: Constraint` and so on for all _sorts_ of other higher-kinded constructions
- I'm guessing [Equality](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/equality_constraints.html) becomes a `type` of the kind `(~) :: Type -> Type -> Constraint` ?? although I'm not quite too _sure_ if its actually [kind-polymorphic](https://downloads.haskell.org/ghc/9.6.0.20230128/docs/users_guide/exts/poly_kinds.html)  i.e. its `(~) :: forall k. k -> k -> Constraint`, and if I can partially apply such a type with type-applications?
- Tuples of **constraints** become themselves **constraints**, e.g. `(Show a, Ord a) :: Constraint`. But does this mean tuples become [kind-polymorphic](https://downloads.haskell.org/ghc/9.6.0.20230128/docs/users_guide/exts/poly_kinds.html), in the sense that the type constructor is `(,) :: forall k. k -> k -> k` ?? That would make sense for why tuples of **constraints** are _themselves_ **constraints** and why tuples of `Type`s are themselves `Type`s. 
- Type-aliases are now allowed to use `Constraint`-**kind**ed type parameters. For example `type Foo (f :: Type -> Constraint) = forall b. f b => b -> b` is allowed.

In Haskell, **constraints** like `Eq a =>` are syntactic sugar for *implicitly passing type-class dictionaries* (records of functions/methods) as arguments. For example:

```haskell
-- here is un-desugared code which defines typeclasses, instances, and uses typeclass-constraints in methods
class Eq a where
  (==), (/=) :: a -> a -> Bool

instance Eq Int where
  (==) = ??
  (/=) = ??

instance Eq a => Eq [a] where
  (==) = ??
  (/=) = ??

foo :: Eq a => a -> a -> Bool
foo x y = x == y

-- typeclasses are desugared into a record of functions, that are threaded-around implicitly
data Eq a = Eq { (==), (/=) :: a -> a -> Bool }

-- instances are desugared into compiler-generated record-values
$fEqInt :: Eq Int
$fEqInt = Eq 
  { (==) = ??
  , (/=) = ??
  }

-- if instances *themselves* have constraints, those are recursively desugared into implicit paremeters
$fEqList :: Eq a -> Eq [a] -- think of it as `$fEqList :: Eq a => Eq [a]`, the `Eq a =>` part becomes `Eq a ->`
$fEqInt eq = Eq
  { (==) = ??
  , (/=) = ??
  }

-- uses in functions are also desugared into the implicit parameters
foo :: Eq a -> a -> a -> Bool
foo eq x y = eq.(==) x y -- "overloaded record dot" syntax used for clarity-effect

```
So in general the strategy is to turn constraints into "proof values" that are compiler-generated and passed around as implicit parameters.
- But what would this mean for like, datatype-constructors rather than functions? What does `data Foo a = Eq a => Foo a` desugar to?
- What about other constraints like equality-constraints, or implicit-parameter constraints? Is the idea that they each get their own "evidence" values generated by the compiler? So maybe `a ~ a` generates something akin to the identity function like `$fIs :: a -> a` or something? But what about `a ~ a`??
- How on earth does any of this interact with [kind-polymorphism](https://downloads.haskell.org/ghc/9.6.0.20230128/docs/users_guide/exts/poly_kinds.html)? Does it even have to?

Here is a bunch of papers on this:
- [How to make ad-hoc polymorphism less ad-hoc](https://dl.acm.org/doi/10.1145/75277.75283): constraints are implicit parameters carrying method implementations
- [System F with type equality coercions](https://dl.acm.org/doi/10.1145/1190315.1190324): describes **System FC** *(intermediate language used by GHC)* where **constraints** are translated into **evidence terms** (explicit arguments) in **System FC**
- [A theory of overloading](https://dl.acm.org/doi/10.1145/581478.581495): formalizes constraints as **dependent function types** ($\prod$-types) in a calculus, e.g. `Eq a => a -> a -> Bool` becomes $\ds \prod(\alpha : \mathrm{Type}). \prod(\mathrm{eq} : \mathrm{Eq} \ \alpha). \alpha \to \alpha \to \mathrm{Bool}$ where $\mathrm{eq}$ is the record of functions for $\alpha$.
- [Modular Type Classes](https://dl.acm.org/doi/pdf/10.1145/1190215.1190229): describes how constraints are **elaborated** into explicit dictionary parameters during typechecking
- [Type Checking with Open Type Functions](https://dl.acm.org/doi/10.1145/1411204.1411215): formalizes how equality constraints (`a ~ b`) are resolved via **coercion terms** that witness type equality.
- [Giving Haskell a promotion](https://dl.acm.org/doi/10.1145/2103786.2103795) theoretical formalization of `Constraint` kinds [kind-polymorphism](https://downloads.haskell.org/ghc/9.6.0.20230128/docs/users_guide/exts/poly_kinds.html) and all sorts of other things in current Haskell's type-system
- [Dependent Types in Haskell](https://www.cis.upenn.edu/~sweirich/papers/eisenberg-thesis.pdf): blurs the line between types and terms, treating constraints as **runtime-relevant evidence**

# Region constraints
So then the idea would be to *extend* the idea of "passing around proofs" to a new kind of constraint: region constraints. 

There is even a formalization of this in the paper [Region-based Resource Management and Lexical Exception Handlers in Continuation-Passing Style](https://link.springer.com/content/pdf/10.1007/978-3-030-99336-8_18.pdf) which: 
- Defines an intermediate language $\Lambda_{\rho}$ which has type-and-effect system which keeps track of regions and is continuation-passing-style
- And also it has a CPS translation from $\Lambda_{\rho}$ to $\text{System F}$ with base types and primitive operations
- They basically have region variables and they can be used in an _almost_ **dependently-typed** manner to produce a "type of proof" of subregioning. So if `r1,r2,Top` are region variables, then `r1 <: r2`, `r1 <: Top` are _dependent types_ which can admit values e.g. `l1: r1 <: r2` means `l1` is a subregioning proof value which has the type `r1 <: r2`. Although I said **dependently-typed** I don't actually _know_ if its truly dependently typed...
- So then these "subregioning proof values" are explicitly threaded around functions that work with regions, but just like the other Haskell constraints we can probably turn them into auto-generated (and hence auto-threaded) constraints ?? So maybe something like `foo :: (r <: Top) => Socket r -> Connection r` or something like that, not too sure. 
- This is good because if I can formalize a Rust-like language into a CPS calculus, I can directly apply this paper's insights
- Also they achieve **first-class functions** which is really dandy :)) because I _really_ don't want to adopt Rust's `Fn*` trait-hierarchy, it is cancerous haha
